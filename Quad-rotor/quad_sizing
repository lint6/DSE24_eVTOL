import numpy as np
import matplotlib.pyplot as plt
import math

class RotorAnalysis:
    def __init__(self, mtow_kg=718.89, n_rotors=4, dl_imperial=3, bank_angle=30, v_max_kmh=150, T_0=288.15, molar_mass=0.0289644, gas_const=8.31432, lapse_rate=0.0065):
        # Constants
        self.MTOW_KG = mtow_kg  # Maximum Takeoff Weight in kg
        self.N_rotors = n_rotors  # Number of rotors
        self.DL_IMPERIAL = dl_imperial  # Disc loading in lb/ft²
        self.bank_angle = bank_angle  # Bank angle during turn [deg]
        self.V_MAX_KMH = v_max_kmh  # Maximum forward speed in km/h

        # Define ISA
        self.T_0 = T_0   # K (sea level standard temperature)
        self.molar_mass = molar_mass  # kg/mol (molar mass of Earth's air)
        self.gas_const = gas_const    # J/(mol·K) (universal gas constant)
        self.lapse_rate = lapse_rate     # K/m (temperature lapse rate)


        # Physical constants
        self.POUNDS_PER_KG = 2.205  # Conversion factor from kg to pounds
        self.FT_TO_M = 3.281  # Conversion factor from ft to m
        self.SPEED_OF_SOUND = 343  # Speed of sound in m/s
        self.rho = 1.225  # Air density [kg/m³]
        self.g = 9.80665  # Gravitational acceleration [m/s²]

        # Derived values
        self.D_v = 0.05 * self.MTOW_KG  # Drag penalty [kg]
        self.k_dl = (1 + (self.D_v / self.MTOW_KG))  # Drag load factor
        self.V_ne = (self.V_MAX_KMH / 3.6) * 1.1  # Never exceed speed [m/s]

        self.V_gust = 30 / self.FT_TO_M
        self.C_lalpha = 5.73  # 1/rad; NACA0012

    def calculate_radius(self):
        mtow_pounds = self.MTOW_KG * self.POUNDS_PER_KG
        radius_ft = np.sqrt((mtow_pounds / self.N_rotors) / (self.DL_IMPERIAL * np.pi))
        radius_m = radius_ft / self.FT_TO_M
        return radius_m

    def calculate_tip_speed(self, diameter_si):
        return 603 / 3.6  # Tip speed in m/s (fixed)

    def calculate_mach_number(self, v_max, v_tip):
        return (v_max + v_tip) / self.SPEED_OF_SOUND

    def perform_analysis(self, c_t_o_fl, c_t_o_turn, c_t_o_turb):
        rotor_radius_m = self.calculate_radius()
        rotor_diameter_m = 2 * rotor_radius_m

        # Tip speed
        v_tip_ms = self.calculate_tip_speed(rotor_diameter_m)
        mach_number = self.calculate_mach_number(self.V_MAX_KMH / 3.6, v_tip_ms)

        # Rotational speed
        omega = v_tip_ms / rotor_radius_m  # Rotational speed in rad/s

        # Advance ratio
        adv_ratio_fl = self.V_ne / (omega * rotor_radius_m)

        # Thrust and solidity in forward flight
        T_fl = self.k_dl * self.MTOW_KG * self.g
        c_t_fl = T_fl / (self.N_rotors * (self.rho * np.pi * rotor_radius_m**2 * (omega * rotor_radius_m)**2))
        o_fl = c_t_fl / c_t_o_fl

        # Solidity during turn
        n_z = 1 / np.cos(self.bank_angle * (np.pi / 180))  # Load factor
        T_turn = n_z * self.k_dl * self.MTOW_KG * self.g
        c_t_turn = T_turn / (self.N_rotors * (self.rho * np.pi * rotor_radius_m**2 * (omega * rotor_radius_m)**2))
        o_turn = c_t_turn / c_t_o_turn

        # Solidity during turbulence
        delta_n = (0.25 * self.C_lalpha * (self.V_gust / (omega * rotor_radius_m))) / c_t_o_turb
        n_z_turb = 2 + delta_n  # 2g pull up (FAA requirement)
        T_turb = n_z_turb * self.k_dl * self.MTOW_KG * self.g
        c_t_turb = T_turb / (self.N_rotors * (self.rho * np.pi * rotor_radius_m ** 2 * (omega * rotor_radius_m) ** 2))
        o_turb = c_t_turb / c_t_o_turb

        # Maximum solidity
        solidity = max(o_fl, o_turn, o_turb)

        # Aspect ratio calculation for different numbers of blades
        N_blades = range(2, 7)
        aspect_ratios = []

        for N_bl in N_blades:
            chord = (solidity * np.pi * rotor_radius_m) / N_bl
            AR_blades = rotor_radius_m**2 / (rotor_diameter_m * chord)
            aspect_ratios.append((N_bl, chord, AR_blades))

        # Return all results including advance ratio
        return rotor_radius_m, rotor_diameter_m, v_tip_ms, mach_number, omega, adv_ratio_fl, o_fl, o_turn, o_turb, solidity, aspect_ratios, n_z

    def plot_aspect_ratios(self, aspect_ratios):
        N_blades = [x[0] for x in aspect_ratios]
        aspect_ratios_values = [x[2] for x in aspect_ratios]

        plt.figure(figsize=(8, 5))
        plt.plot(N_blades, aspect_ratios_values, marker='o', label="Aspect Ratio")
        plt.title("Aspect Ratio vs. Number of Blades")
        plt.xlabel("Number of Blades")
        plt.ylabel("Aspect Ratio")
        plt.grid(True)
        plt.legend()
        plt.show()

    def calculate_chord(self, N_bl, solidity, rotor_radius_m):
        """Calculate the blade chord length given the number of blades and solidity."""
        chord = (solidity * np.pi * rotor_radius_m) / N_bl
        return chord

    def interact(self):
        # Perform analysis with default coefficients to get advance ratio first
        results = self.perform_analysis(c_t_o_fl=0.12, c_t_o_turn=0.15, c_t_o_turb=0.17)

        # Unpack results
        rotor_radius, rotor_diameter, v_tip, mach_number, omega, adv_ratio_fl, o_fl, o_turn, o_turb, solidity, aspect_ratios, n_z = results

        # Print advance ratio and other results
        print(f"Advance Ratio in forward flight = {adv_ratio_fl:.2f}")
        print(f"Rotor Radius [m]: {rotor_radius:.2f}")
        print(f"Rotor Diameter [m]: {rotor_diameter:.2f}")
        print(f"Tip Speed [m/s]: {v_tip:.2f}")
        print(f"Mach Number: {mach_number:.2f}")
        print(f"Rotational Speed (Omega) [rad/s]: {omega:.2f}")
        print(f"RPMs : {omega*(60/(2*np.pi)): .2f}")

        # Now ask for user input for thrust coefficients
        print("Please enter the thrust coefficients:")
        c_t_o_fl = float(input("Enter thrust coefficient for forward flight (c_t_o_fl): "))
        c_t_o_turn = float(input("Enter thrust coefficient for turning flight (c_t_o_turn): "))
        c_t_o_turb = float(input("Enter thrust coefficient for turbulence (c_t_o_turb): "))

        # Perform analysis with user-provided coefficients
        results_with_input = self.perform_analysis(c_t_o_fl, c_t_o_turn, c_t_o_turb)

        # Unpack new results
        rotor_radius, rotor_diameter, v_tip, mach_number, omega, adv_ratio_fl, o_fl, o_turn, o_turb, solidity, aspect_ratios, n_z = results_with_input

        # Print key results with user inputs
        print(f"Solidity in Forward Flight: {o_fl:.4f}")
        print(f"Solidity during Turn: {o_turn:.4f}")
        print(f"Solidity during Turbulence: {o_turb:.4f}")
        print(f"Solidity used: {solidity:.4f}")

        # Plot results
        self.plot_aspect_ratios(aspect_ratios)

        # Ask user for the number of blades they want and calculate the corresponding chord
        selected_blades = int(input("Enter the number of blades you want (between 2 and 6): "))
        if selected_blades not in range(2, 7):
            print("Invalid number of blades selected. Please choose between 2 and 6 blades.")
        else:
            # Get the selected aspect ratio and chord
            selected_aspect_ratio = None
            selected_chord = None
            for N_bl, chord, AR_bl in aspect_ratios:
                if N_bl == selected_blades:
                    selected_aspect_ratio = AR_bl
                    selected_chord = chord

            # Print the results
            print(f"Selected number of blades: {selected_blades}")
            print(f"Corresponding blade chord length: {selected_chord:.4f} meters")
            print(f"Corresponding aspect ratio: {selected_aspect_ratio:.4f}")


class PerformanceAnalysis:
    def __init__(self, rotor_analysis: RotorAnalysis, vertical_climb_speed: float = 0.76):
        self.rotor_analysis = rotor_analysis
        self.V_vertical_climb = vertical_climb_speed

        # Use values from RotorAnalysis
        self.mtow = rotor_analysis.MTOW_KG
        self.N_rotors = rotor_analysis.N_rotors
        self.rho = rotor_analysis.rho
        self.g = rotor_analysis.g
        self.Cl_alpha = rotor_analysis.C_lalpha

        # ISA
        self.T_0 = rotor_analysis.T_0
        self.molar_mass = rotor_analysis.molar_mass  
        self.gas_const = rotor_analysis.gas_const    
        self.lapse_rate = rotor_analysis.lapse_rate     

        # Perform rotor sizing
        self.results = rotor_analysis.perform_analysis(c_t_o_fl=0.12, c_t_o_turn=0.15, c_t_o_turb=0.17)
        self.rotor_radius, self.rotor_diameter, self.v_tip, self.mach_number, self.omega, self.adv_ratio_fl, self.o_fl, self.o_turn, self.o_turb, self.solidity, self.aspect_ratios, self.n_z  = self.results

        # Derived parameters
        self.rotor_area = np.pi * (self.rotor_radius**2)  # Rotor swept area (m^2)
        self.weight_per_rotor = (self.mtow / self.N_rotors) * self.g  # Weight supported by each rotor (N)
        self.FM = 0.78 # figure of merit (assumed)

    def calculate_hover_induced_velocity(self):
        """Calculate hover induced velocity (m/s)."""
        return np.sqrt(self.weight_per_rotor / (2 * self.rho * self.rotor_area))

    def calculate_climb_induced_velocity(self):
        """Calculate climb induced velocity (m/s)."""
        return (-self.V_vertical_climb / 2) + np.sqrt((self.V_vertical_climb / 2)**2 + (self.weight_per_rotor / (2 * self.rho * self.rotor_area)))

    def calculate_disk_area(self):
        """Calculate total disk area of the quadcopter"""
        S_disk = self.rotor_area*4
        return S_disk
    
    def calculate_power_req_hover(self):
        P_req_hover = ((self.mtow*self.g)**(3/2))/(np.sqrt(2*self.rho*self.calculate_disk_area())*self.FM)
        return P_req_hover
    
    def calculate_power_loading_hover(self):
        P_load_hover = (self.mtow) / (self.calculate_power_req_hover()/1000)
        return P_load_hover
    
    def calculate_hoge_ceiling(self):
        #altitude conversion needs to be implemented properly!!!
        P_max = self.calculate_power_req_hover() + 10000 #placeholder
        rho_max = (self.T)**3 / (2 * P_max**2 * self.FM**2 * self.calculate_disk_area())

        altitude_this_is_wrong = (self.T_0 * (1 - ((rho_max / self.rho)**(1/((self.g/(self.gas_const*self.lapse_rate)) - 1))))) / self.lapse_rate
        return altitude_this_is_wrong
    
    #In order to find Forward Flight P_req, we need to calculate some new values:
    #Thrust coefficient
    def calculate_C_T(self): 
        self.T = self.mtow *self.g
        C_T = (self.T) / (self.rho * np.pi * (self.rotor_radius) ** 2 *(self.omega * self.rotor_radius)**2 )
        return C_T
    
    #Average C_l
    def calculate_average_C_l(self):
        average_C_l = 6.6 * self.calculate_C_T() / self.solidity
        return average_C_l

    #alpha_m
    def calculate_alpha_m(self):
        alpha_m = self.calculate_average_C_l() / self.Cl_alpha
        return alpha_m
    
    #average_C_D_p
    def calculate_average_C_D_p(self):
        average_C_D_p = 0.0087 - 0.0216 * self.calculate_alpha_m() + 0.4 * self.calculate_alpha_m() ** 2
        return average_C_D_p

    #Profile drag power for hover
    def calculate_P_p_hov(self):
        P_p_hov = self.solidity * self.calculate_average_C_D_p() / 8 * self.rho * (self.omega * self.rotor_radius) ** 3 * np.pi * self.rotor_radius **2
        return P_p_hov 

    #Profile drag power for forward flight   
    def calculate_P_p(self):
        P_p = self.calculate_P_p_hov() * (1 + 4.65 * self.adv_ratio_fl ** 2)
        return P_p
    
    
    def display_results(self):
        """Display power requirements and induced velocities."""
        v_i_hover = self.calculate_hover_induced_velocity()
        v_i_climb = self.calculate_climb_induced_velocity()
        disk_area = self.calculate_disk_area()
        power_requirements = self.calculate_power_req_hover()
        power_loading_hover = self.calculate_power_loading_hover()
        profile_power_fl = self.calculate_P_p()
        HOGE_ceiling = self.calculate_hoge_ceiling()       

        #print(f'Hover induced velocity: {v_i_hover:.2f} m/s')
        #print(f'Climb induced velocity: {v_i_climb:.2f} m/s')
        print(f'Disk Area: {disk_area:.2f} m2')
        print(f'Power required for hover: {power_requirements / 1000:.2f} kW')
        print(f'Power loading for hover: {power_loading_hover:.2f} kg/kW')
        print(f'Profile power drag: {profile_power_fl / 1000:.2f} kW')
        print(f'HOGE ceiling: {HOGE_ceiling:.5f} m')


class PowerAnalysis:
    def __init__(self):
        #values from rotor sizing
        self.N_rotors = RotorAnalysis.N_rotors     # get the amount of rotors    
        #values from performance
        self.P_req_hover = PerformanceAnalysis.calculate_power_req_hover()     # get the required power for hover
        #add power required for take off, climb, cruise, descent, loiter, land
        self.t4 = None
        #import the V_climb1!!


    
    def calculate_missionphase_time(self):
        # HIGE 1
        t1 = 15
        # Vertical Climb
        delta_h1 = 60.0     #[m]
        Vroc = 0.76         #[m/s]
        t2 = delta_h1 / Vroc
        # HOGE 1  
        t3 = 10             #[s]
        # Steady Climb 1
        delta_h2 = 300-delta_h1
        gamma_1 = 9         #[deg]
        ddistance_h2 = delta_h2 / np.sin(9*np.pi/180)      #Diagonal distance after converting deg to rad
        hdistance_h2 = delta_h2 / np.tan(9*np.pi/180)      #Horizontal distance after converting deg to rad
        #t4 = hdistance_h2 / V_climb1        #time of climb 1 with horizontal climb speed V_climb1
        # Cruise 1


        self.t1 = t1 
        return self.t1 
    

# Main Execution
if __name__ == "__main__":
    # Initialize the analysis with default values
    rotor_analysis = RotorAnalysis()

    # Start the interaction method that handles all the user input and analysis
    rotor_analysis.interact()

    # Initialize PerformanceAnalysis with the rotor analysis instance
    performance_analysis = PerformanceAnalysis(rotor_analysis)

    # Display results
    performance_analysis.display_results()

    